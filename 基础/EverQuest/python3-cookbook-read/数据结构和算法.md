> 数据结构和算法

#### 数据结构与算法

##### 解压序列赋值给多个变量

-  任何的序列（或者是可迭代对象）可以通过一个简单的赋值语句解压并赋值给多个变量。 唯一的前提就是变量的数量必须跟序列元素的数量是一样的

- 解压赋值可以用在任何可迭代对象上面，而不仅仅是列表或者元组。 包括字符串，文件对象，迭代器和生成器

- 部分解压，使用任意变量名占位

- 示例

  ```python
  # 01
  data = [ 'ACME', 50, 91.1, (2012, 12, 21) ]
  name, shares, price, date = data
  date  # (2012, 12, 21)
  # 02
  name, shares, price, (year, mon, day) = data
  year  # 2012
  day  # 21
  # 03
  s = 'Hello'
  a, b, c, d, e = s
  a  # 'H'
  # 04
  data = [ 'ACME', 50, 91.1, (2012, 12, 21) ]
  _, shares, price, _ = data
  shares  # 50
  price  # 91.1
  ```

##### 解压可迭代对象赋值给多个变量

-  星号表达式(星号解压语法)解决`ValueError`

- 扩展的迭代解压语法是专门为解压不确定个数或任意个数元素的可迭代对象而设计的。 通常，这些可迭代对象的元素结构有确定的规则（比如第 1 个元素后面都是电话号码）， 星号表达式让开发人员可以很容易的利用这些规则来解压出元素来。 而不是通过一些比较复杂的手段去获取这些关联的元素值

- 示例

  ```python
  record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212')
  name, email, *phone_numbers = record
  name  # 'Dave'
  email  # 'dave@example.com'
  phone_numbers  # ['773-555-1212', '847-555-1212']
  # 可变长元组的序列
  records = [
      ('foo', 1, 2),
      ('bar', 'hello'),
      ('foo', 3, 4),
  ]
  
  def do_foo(x, y):
      print('foo', x, y)
  
  def do_bar(s):
      print('bar', s)
  
  for tag, *args in records:
      if tag == 'foo':
          do_foo(*args)
      elif tag == 'bar':
          do_bar(*args)
  # 字符串操作
  line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'
  uname, *fields, homedir, sh = line.split(':')
  uname  # 'nobody'
  homedir  # '/var/empty'
  sh  # '/usr/bin/false'
  # 部分解压
  record = ('ACME', 50, 123.45, (12, 18, 2012))
  name, *_, (*_, year) = record
  name  # 'ACME'
  year  # 2012
  # 分割列表
  items = [1, 10, 7, 4, 5, 9]
  head, *tail = items
  head  # 1
  tail  # [10, 7, 4, 5, 9]
  # 递归（不建议）
  def sum(items):
       head, *tail = items
       return head + sum(tail) if tail else head
  
  sum(items)  # 36
  
  ```

##### 保留最后 N 个元素

-  使用 `collections.deque(maxlen=N)` 构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满的时候， 最老的元素会自动被移除掉

- 一般的， `deque` 类可以被用在任何你只需要一个简单队列数据结构的场合。 如果你不设置最大队列大小，那么就会得到一个无限大小队列，你可以在队列的两端执行添加和弹出元素的操作

- 在队列两端插入或删除元素时间复杂度都是 `O(1)` ，区别于列表，在列表的开头插入或删除元素的时间复杂度为 `O(N)` 

- 示例

  ```python
  # 基本操作
  q = deque(maxlen=3)
  q.append(1)
  q.append(2)
  q.append(3)
  q  # deque([1, 2, 3], maxlen=3)
  q.append(4)
  q  # deque([2, 3, 4], maxlen=3)
  q.appendleft(4)  # deque([4，2, 3], maxlen=3)
  q.pop()  # 3
  q.popleft()  # deque([2], maxlen=3)
  ```

##### 查找最大或最小的 N 个元素

- 